# ############################################################################ #
# Global config
# ############################################################################ #

# #### Input, output and names ####

OUT_DIR ?= build
LOCAL_LIBS ?= extra_libs
SRC ?= src $(LOCAL_LIBS)
PROGNAME ?= rtfi
OUT_FILE = $(OUT_DIR)/$(PROGNAME)

PYTHON ?= python3

# preprocessor
IPATH += $(addprefix -I,$(LOCAL_LIBS))
CPPFLAGS += $(IPATH) -D_DEFAULT_SOURCE

# compiler
WFLAGS ?= -pedantic -Wall -Wextra -Wconversion

OFLAGS ?= -O2 -ffast-math -fflush-to-zero -fomit-frame-pointer -march=native
CFLAGS += $(WFLAGS) -std=c99 -ffunction-sections -fdata-sections

# Linking

LIBS = -lm -ljack -lSDL -lrt -lpthread

# Other tools

NM ?= nm

# windows hacks
ifeq ($(strip $(OS)), Windows_NT)
MKDIR           ?= md
RM		?= del
RMDIR		?= rmdir /s /q
PATHSEP := \\
else
MKDIR           ?= mkdir -p
RM		?= rm -f
RMDIR		?= rm -rf
PATHSEP := /
endif

# rwildcard  dir,pattern
#	Use this function to recursively search for all files with a certain
#	extension.
#	Unix find is better for this, but it may not be available on windows.
rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) $(filter $(subst *,%,$2),$d))

# rdwildcard  dir
# 	Find all directories
rdwildcard=$(foreach d,$(wildcard $1*/),$(call rdwildcard,$d/) $(filter %/,$d))

# transform infiles,in_extension,out_extension
#	Convert input filenames into output filenames by changing the extension
#	and the directory
transform=$(1:%$2=$(OUT_DIR)/%$3)

# Manual dependencies for autogenerated files. These files are commited to
# the repo to make compilation independent of the python libraries used in
# the scrips.

GENERATED_DIR = src_generated
PARAM_FILE = $(GENERATED_DIR)/rtfi_params.c
DEFINES_AUX_FILE = $(GENERATED_DIR)/rtfi_defines.h
SPEC_FILE = $(GENERATED_DIR)/spectral_tables.c

GENFILES = $(PARAM_FILE) $(DEFINES_AUX_FILE) $(SPEC_FILE)

RTFI_GEN = scripts/rtfi.py

# ############################################################################ #
# Automatic dependency generation
# ############################################################################ #


# flags for the preprocessor
DEPFLAGS ?= -MM -MP -MQ $@ $(patsubst %,-MQ %,$(call transform,$*.o $*.proof))

# ######## Let's make a list of all files which exist currently ############ #
C_FILES=$(call rwildcard,$(SRC),*.c)
H_FILES=$(call rwildcard,$(SRC) $(INCLUDE)/,*.h)
SRC_DIRECTORIES=$(addsuffix /,$(SRC)) $(call rdwildcard,$(SRC))
OUT_DIRECTORIES=$(call rdwildcard,$(OUT_DIR)/)

# .d files are dependency listings for .c files
D_FILES=$(call rwildcard,$(OUT_DIR)/,*.d)

O_FILES=$(call rwildcard,$(OUT_DIR)/,*.o)
GCH_FILES=$(call rwildcard,$(OUT_DIR)/,*.gch)

# ###### Make a list of files that need to be produced ###############

# each .c produces a .o
NEEDED_OBJECTS = $(call transform,$(C_FILES),.c,.o)
NEEDED_DEPS = $(call transform,$(C_FILES),.c,.d)
NEEDED_DIRS = $(OUT_DIR) $(call transform,$(SRC_DIRECTORIES),,)

# More on automatic dependencies later

# ############################################################################ #
# Rules for building the project
# ############################################################################ #

.PHONY: all library proofs

all: $(OUT_FILE) $(OUT_FILE).sym

# ###################### Output directory creation ########################### #

$(OUT_DIR):
	$(MKDIR) $@

$(OUT_DIR)/%/:
	$(MKDIR) $@

.PHONY: directories
directories: | $(NEEDED_DIRS)

# ######################## Rules for cleaning ################################ #

.PHONY: depclean
depclean: $(foreach dfile,$(D_FILES),$(dfile)-clean)

.PHONY: clean
clean: $(foreach f,$(O_FILES) $(GCH_FILES),$(f)-clean)

.PHONY: allclean
allclean: clean depclean

.PHONY: wipe
wipe: allclean $(OUT_DIR)-dirclean

# Rules to clean each type of file

%-clean:
	$(RM) $*

%-dirclean:
	$(RMDIR) $*

# ###################### Dependency handling ################################# #

# If we are only cleaning then ignore the dependencies
_REALGOAL = $(if $(MAKECMDGOALS),$(MAKECMDGOALS),all)
ifneq (,$(filter-out depclean clean wipe genfiles,$(_REALGOAL)))
include $(NEEDED_DEPS)
endif

$(OUT_DIR)/%.d: %.c | directories
	@$(CC) $(CPPFLAGS) $(CFLAGS) $(DEPFLAGS) $< -o $@

# Code generation

.PHONY: genfiles

genfiles:  $(GENFILES)

$(GENFILES): $(RTFI_GEN)
	$(PYTHON) $< --write \
		--mainfile $(PARAM_FILE) \
		--auxfile $(DEFINES_AUX_FILE) \
		--specfile $(SPEC_FILE)

# ##################### Output file generation ############################### #

# create a executable file from object files
$(OUT_FILE): $(NEEDED_OBJECTS) | directories
	$(CC) $(CFLAGS) $^ $(LIBS) -o $@

# if nm fails for some reason, the file will still be created (because of
# the redirect. Using an intermediate target causes make to delete it.
%.sym-tmp: %
	$(NM) -n $< > $@

%.sym: %.sym-tmp
	cp $< $@

$(OUT_DIR)/%.o: | directories
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
